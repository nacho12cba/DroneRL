# 1 "./src/main/io/rcdevice.c"
# 1 "<built-in>"
# 1 "<command-line>"
# 1 "/usr/include/stdc-predef.h" 1 3 4
# 1 "<command-line>" 2
# 1 "./src/main/io/rcdevice.c"
# 18 "./src/main/io/rcdevice.c"
# 1 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stdbool.h" 1 3 4
# 19 "./src/main/io/rcdevice.c" 2
# 1 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stdint.h" 1 3 4
# 9 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stdint.h" 3 4
# 1 "/usr/include/stdint.h" 1 3 4
# 26 "/usr/include/stdint.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 33 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 3 4
# 1 "/usr/include/features.h" 1 3 4
# 424 "/usr/include/features.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 1 3 4
# 427 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 428 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/long-double.h" 1 3 4
# 429 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 2 3 4
# 425 "/usr/include/features.h" 2 3 4
# 448 "/usr/include/features.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/gnu/stubs.h" 1 3 4
# 10 "/usr/include/x86_64-linux-gnu/gnu/stubs.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/gnu/stubs-64.h" 1 3 4
# 11 "/usr/include/x86_64-linux-gnu/gnu/stubs.h" 2 3 4
# 449 "/usr/include/features.h" 2 3 4
# 34 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 2 3 4
# 27 "/usr/include/stdint.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 28 "/usr/include/x86_64-linux-gnu/bits/types.h" 2 3 4



# 30 "/usr/include/x86_64-linux-gnu/bits/types.h" 3 4
typedef unsigned char __u_char;
typedef unsigned short int __u_short;
typedef unsigned int __u_int;
typedef unsigned long int __u_long;


typedef signed char __int8_t;
typedef unsigned char __uint8_t;
typedef signed short int __int16_t;
typedef unsigned short int __uint16_t;
typedef signed int __int32_t;
typedef unsigned int __uint32_t;

typedef signed long int __int64_t;
typedef unsigned long int __uint64_t;







typedef long int __quad_t;
typedef unsigned long int __u_quad_t;







typedef long int __intmax_t;
typedef unsigned long int __uintmax_t;
# 130 "/usr/include/x86_64-linux-gnu/bits/types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/typesizes.h" 1 3 4
# 131 "/usr/include/x86_64-linux-gnu/bits/types.h" 2 3 4


typedef unsigned long int __dev_t;
typedef unsigned int __uid_t;
typedef unsigned int __gid_t;
typedef unsigned long int __ino_t;
typedef unsigned long int __ino64_t;
typedef unsigned int __mode_t;
typedef unsigned long int __nlink_t;
typedef long int __off_t;
typedef long int __off64_t;
typedef int __pid_t;
typedef struct { int __val[2]; } __fsid_t;
typedef long int __clock_t;
typedef unsigned long int __rlim_t;
typedef unsigned long int __rlim64_t;
typedef unsigned int __id_t;
typedef long int __time_t;
typedef unsigned int __useconds_t;
typedef long int __suseconds_t;

typedef int __daddr_t;
typedef int __key_t;


typedef int __clockid_t;


typedef void * __timer_t;


typedef long int __blksize_t;




typedef long int __blkcnt_t;
typedef long int __blkcnt64_t;


typedef unsigned long int __fsblkcnt_t;
typedef unsigned long int __fsblkcnt64_t;


typedef unsigned long int __fsfilcnt_t;
typedef unsigned long int __fsfilcnt64_t;


typedef long int __fsword_t;

typedef long int __ssize_t;


typedef long int __syscall_slong_t;

typedef unsigned long int __syscall_ulong_t;



typedef __off64_t __loff_t;
typedef char *__caddr_t;


typedef long int __intptr_t;


typedef unsigned int __socklen_t;




typedef int __sig_atomic_t;
# 28 "/usr/include/stdint.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wchar.h" 1 3 4
# 29 "/usr/include/stdint.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 30 "/usr/include/stdint.h" 2 3 4




# 1 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h" 3 4
typedef __int8_t int8_t;
typedef __int16_t int16_t;
typedef __int32_t int32_t;
typedef __int64_t int64_t;
# 35 "/usr/include/stdint.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h" 3 4
typedef __uint8_t uint8_t;
typedef __uint16_t uint16_t;
typedef __uint32_t uint32_t;
typedef __uint64_t uint64_t;
# 38 "/usr/include/stdint.h" 2 3 4





typedef signed char int_least8_t;
typedef short int int_least16_t;
typedef int int_least32_t;

typedef long int int_least64_t;






typedef unsigned char uint_least8_t;
typedef unsigned short int uint_least16_t;
typedef unsigned int uint_least32_t;

typedef unsigned long int uint_least64_t;
# 68 "/usr/include/stdint.h" 3 4
typedef signed char int_fast8_t;

typedef long int int_fast16_t;
typedef long int int_fast32_t;
typedef long int int_fast64_t;
# 81 "/usr/include/stdint.h" 3 4
typedef unsigned char uint_fast8_t;

typedef unsigned long int uint_fast16_t;
typedef unsigned long int uint_fast32_t;
typedef unsigned long int uint_fast64_t;
# 97 "/usr/include/stdint.h" 3 4
typedef long int intptr_t;


typedef unsigned long int uintptr_t;
# 111 "/usr/include/stdint.h" 3 4
typedef __intmax_t intmax_t;
typedef __uintmax_t uintmax_t;
# 10 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stdint.h" 2 3 4
# 20 "./src/main/io/rcdevice.c" 2
# 1 "/usr/include/string.h" 1 3 4
# 26 "/usr/include/string.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 27 "/usr/include/string.h" 2 3 4






# 1 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h" 1 3 4
# 216 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h" 3 4
typedef long unsigned int size_t;
# 34 "/usr/include/string.h" 2 3 4
# 42 "/usr/include/string.h" 3 4
extern void *memcpy (void *__restrict __dest, const void *__restrict __src,
       size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern void *memmove (void *__dest, const void *__src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));





extern void *memccpy (void *__restrict __dest, const void *__restrict __src,
        int __c, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));




extern void *memset (void *__s, int __c, size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int memcmp (const void *__s1, const void *__s2, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 90 "/usr/include/string.h" 3 4
extern void *memchr (const void *__s, int __c, size_t __n)
      __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 121 "/usr/include/string.h" 3 4
extern char *strcpy (char *__restrict __dest, const char *__restrict __src)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

extern char *strncpy (char *__restrict __dest,
        const char *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern char *strcat (char *__restrict __dest, const char *__restrict __src)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

extern char *strncat (char *__restrict __dest, const char *__restrict __src,
        size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strcmp (const char *__s1, const char *__s2)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern int strncmp (const char *__s1, const char *__s2, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strcoll (const char *__s1, const char *__s2)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern size_t strxfrm (char *__restrict __dest,
         const char *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));



# 1 "/usr/include/x86_64-linux-gnu/bits/types/locale_t.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/types/locale_t.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/__locale_t.h" 1 3 4
# 28 "/usr/include/x86_64-linux-gnu/bits/types/__locale_t.h" 3 4
struct __locale_struct
{

  struct __locale_data *__locales[13];


  const unsigned short int *__ctype_b;
  const int *__ctype_tolower;
  const int *__ctype_toupper;


  const char *__names[13];
};

typedef struct __locale_struct *__locale_t;
# 23 "/usr/include/x86_64-linux-gnu/bits/types/locale_t.h" 2 3 4

typedef __locale_t locale_t;
# 153 "/usr/include/string.h" 2 3 4


extern int strcoll_l (const char *__s1, const char *__s2, locale_t __l)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 3)));


extern size_t strxfrm_l (char *__dest, const char *__src, size_t __n,
    locale_t __l) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 4)));





extern char *strdup (const char *__s)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));






extern char *strndup (const char *__string, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));
# 225 "/usr/include/string.h" 3 4
extern char *strchr (const char *__s, int __c)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 252 "/usr/include/string.h" 3 4
extern char *strrchr (const char *__s, int __c)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 272 "/usr/include/string.h" 3 4
extern size_t strcspn (const char *__s, const char *__reject)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern size_t strspn (const char *__s, const char *__accept)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 302 "/usr/include/string.h" 3 4
extern char *strpbrk (const char *__s, const char *__accept)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 329 "/usr/include/string.h" 3 4
extern char *strstr (const char *__haystack, const char *__needle)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));




extern char *strtok (char *__restrict __s, const char *__restrict __delim)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));



extern char *__strtok_r (char *__restrict __s,
    const char *__restrict __delim,
    char **__restrict __save_ptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3)));

extern char *strtok_r (char *__restrict __s, const char *__restrict __delim,
         char **__restrict __save_ptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3)));
# 384 "/usr/include/string.h" 3 4
extern size_t strlen (const char *__s)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));




extern size_t strnlen (const char *__string, size_t __maxlen)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));




extern char *strerror (int __errnum) __attribute__ ((__nothrow__ , __leaf__));
# 409 "/usr/include/string.h" 3 4
extern int strerror_r (int __errnum, char *__buf, size_t __buflen) __asm__ ("" "__xpg_strerror_r") __attribute__ ((__nothrow__ , __leaf__))

                        __attribute__ ((__nonnull__ (2)));
# 427 "/usr/include/string.h" 3 4
extern char *strerror_l (int __errnum, locale_t __l) __attribute__ ((__nothrow__ , __leaf__));



# 1 "/usr/include/strings.h" 1 3 4
# 23 "/usr/include/strings.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h" 1 3 4
# 24 "/usr/include/strings.h" 2 3 4










extern int bcmp (const void *__s1, const void *__s2, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern void bcopy (const void *__src, void *__dest, size_t __n)
  __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern void bzero (void *__s, size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 68 "/usr/include/strings.h" 3 4
extern char *index (const char *__s, int __c)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 96 "/usr/include/strings.h" 3 4
extern char *rindex (const char *__s, int __c)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));






extern int ffs (int __i) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));





extern int ffsl (long int __l) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
__extension__ extern int ffsll (long long int __ll)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));



extern int strcasecmp (const char *__s1, const char *__s2)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strncasecmp (const char *__s1, const char *__s2, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));






extern int strcasecmp_l (const char *__s1, const char *__s2, locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 3)));



extern int strncasecmp_l (const char *__s1, const char *__s2,
     size_t __n, locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 4)));








# 1 "/usr/include/x86_64-linux-gnu/bits/strings_fortified.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/strings_fortified.h" 3 4
extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) void
__attribute__ ((__nothrow__ , __leaf__)) bcopy (const void *__src, void *__dest, size_t __len)
{
  (void) __builtin___memmove_chk (__dest, __src, __len, __builtin_object_size (__dest, 0));
}

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) void
__attribute__ ((__nothrow__ , __leaf__)) bzero (void *__dest, size_t __len)
{
  (void) __builtin___memset_chk (__dest, '\0', __len, __builtin_object_size (__dest, 0));
}
# 145 "/usr/include/strings.h" 2 3 4
# 432 "/usr/include/string.h" 2 3 4



extern void explicit_bzero (void *__s, size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern char *strsep (char **__restrict __stringp,
       const char *__restrict __delim)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));




extern char *strsignal (int __sig) __attribute__ ((__nothrow__ , __leaf__));


extern char *__stpcpy (char *__restrict __dest, const char *__restrict __src)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern char *stpcpy (char *__restrict __dest, const char *__restrict __src)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));



extern char *__stpncpy (char *__restrict __dest,
   const char *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern char *stpncpy (char *__restrict __dest,
        const char *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
# 494 "/usr/include/string.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h" 1 3 4
# 30 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h" 3 4
extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) void *
__attribute__ ((__nothrow__ , __leaf__)) memcpy (void *__restrict __dest, const void *__restrict __src, size_t __len)

{
  return __builtin___memcpy_chk (__dest, __src, __len, __builtin_object_size (__dest, 0));
}

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) void *
__attribute__ ((__nothrow__ , __leaf__)) memmove (void *__dest, const void *__src, size_t __len)
{
  return __builtin___memmove_chk (__dest, __src, __len, __builtin_object_size (__dest, 0));
}
# 58 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h" 3 4
extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) void *
__attribute__ ((__nothrow__ , __leaf__)) memset (void *__dest, int __ch, size_t __len)
{
# 71 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h" 3 4
  return __builtin___memset_chk (__dest, __ch, __len, __builtin_object_size (__dest, 0));
}




void __explicit_bzero_chk (void *__dest, size_t __len, size_t __destlen)
  __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) void
__attribute__ ((__nothrow__ , __leaf__)) explicit_bzero (void *__dest, size_t __len)
{
  __explicit_bzero_chk (__dest, __len, __builtin_object_size (__dest, 0));
}


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) char *
__attribute__ ((__nothrow__ , __leaf__)) strcpy (char *__restrict __dest, const char *__restrict __src)
{
  return __builtin___strcpy_chk (__dest, __src, __builtin_object_size (__dest, 2 > 1));
}
# 102 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h" 3 4
extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) char *
__attribute__ ((__nothrow__ , __leaf__)) strncpy (char *__restrict __dest, const char *__restrict __src, size_t __len)

{
  return __builtin___strncpy_chk (__dest, __src, __len, __builtin_object_size (__dest, 2 > 1));
}


extern char *__stpncpy_chk (char *__dest, const char *__src, size_t __n,
       size_t __destlen) __attribute__ ((__nothrow__ , __leaf__));
extern char *__stpncpy_alias (char *__dest, const char *__src, size_t __n) __asm__ ("" "stpncpy") __attribute__ ((__nothrow__ , __leaf__))
                                 ;

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) char *
__attribute__ ((__nothrow__ , __leaf__)) stpncpy (char *__dest, const char *__src, size_t __n)
{
  if (__builtin_object_size (__dest, 2 > 1) != (size_t) -1
      && (!__builtin_constant_p (__n) || __n > __builtin_object_size (__dest, 2 > 1)))
    return __stpncpy_chk (__dest, __src, __n, __builtin_object_size (__dest, 2 > 1));
  return __stpncpy_alias (__dest, __src, __n);
}


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) char *
__attribute__ ((__nothrow__ , __leaf__)) strcat (char *__restrict __dest, const char *__restrict __src)
{
  return __builtin___strcat_chk (__dest, __src, __builtin_object_size (__dest, 2 > 1));
}


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) char *
__attribute__ ((__nothrow__ , __leaf__)) strncat (char *__restrict __dest, const char *__restrict __src, size_t __len)

{
  return __builtin___strncat_chk (__dest, __src, __len, __builtin_object_size (__dest, 2 > 1));
}
# 495 "/usr/include/string.h" 2 3 4




# 21 "./src/main/io/rcdevice.c" 2

# 1 "./src/main/common/crc.h" 1
# 18 "./src/main/common/crc.h"
       


# 20 "./src/main/common/crc.h"
struct sbuf_s;

uint16_t crc16_ccitt(uint16_t crc, unsigned char a);
uint16_t crc16_ccitt_update(uint16_t crc, const void *data, uint32_t length);
struct sbuf_s;
void crc16_ccitt_sbuf_append(struct sbuf_s *dst, uint8_t *start);

uint8_t crc8_dvb_s2(uint8_t crc, unsigned char a);
uint8_t crc8_dvb_s2_update(uint8_t crc, const void *data, uint32_t length);
void crc8_dvb_s2_sbuf_append(struct sbuf_s *dst, uint8_t *start);
uint8_t crc8_xor_update(uint8_t crc, const void *data, uint32_t length);
void crc8_xor_sbuf_append(struct sbuf_s *dst, uint8_t *start);
# 23 "./src/main/io/rcdevice.c" 2
# 1 "./src/main/common/maths.h" 1
# 18 "./src/main/common/maths.h"
       
# 55 "./src/main/common/maths.h"
typedef int32_t fix12_t;

typedef struct stdev_s
{
    float m_oldM, m_newM, m_oldS, m_newS;
    int m_n;
} stdev_t;


typedef struct fp_vector {
    float X;
    float Y;
    float Z;
} t_fp_vector_def;

typedef union u_fp_vector {
    float A[3];
    t_fp_vector_def V;
} t_fp_vector;



typedef struct fp_angles {
    float roll;
    float pitch;
    float yaw;
} fp_angles_def;

typedef union {
    float raw[3];
    fp_angles_def angles;
} fp_angles_t;

int gcd(int num, int denom);
float powerf(float base, int exp);
int32_t applyDeadband(int32_t value, int32_t deadband);

void devClear(stdev_t *dev);
void devPush(stdev_t *dev, float x);
float devVariance(stdev_t *dev);
float devStandardDeviation(stdev_t *dev);
float degreesToRadians(int16_t degrees);

int scaleRange(int x, int srcFrom, int srcTo, int destFrom, int destTo);

void normalizeV(struct fp_vector *src, struct fp_vector *dest);

void rotateV(struct fp_vector *v, fp_angles_t *delta);
void buildRotationMatrix(fp_angles_t *delta, float matrix[3][3]);

int32_t quickMedianFilter3(int32_t * v);
int32_t quickMedianFilter5(int32_t * v);
int32_t quickMedianFilter7(int32_t * v);
int32_t quickMedianFilter9(int32_t * v);

float quickMedianFilter3f(float * v);
float quickMedianFilter5f(float * v);
float quickMedianFilter7f(float * v);
float quickMedianFilter9f(float * v);


float sin_approx(float x);
float cos_approx(float x);
float atan2_approx(float y, float x);
float acos_approx(float x);
# 129 "./src/main/common/maths.h"
void arraySubInt32(int32_t *dest, int32_t *array1, int32_t *array2, int count);

int16_t qPercent(fix12_t q);
int16_t qMultiply(fix12_t q, int16_t input);
fix12_t qConstruct(int16_t num, int16_t den);

static inline int constrain(int amt, int low, int high)
{
    if (amt < low)
        return low;
    else if (amt > high)
        return high;
    else
        return amt;
}

static inline float constrainf(float amt, float low, float high)
{
    if (amt < low)
        return low;
    else if (amt > high)
        return high;
    else
        return amt;
}
# 24 "./src/main/io/rcdevice.c" 2
# 1 "./src/main/common/streambuf.h" 1
# 18 "./src/main/common/streambuf.h"
       





typedef struct sbuf_s {
    uint8_t *ptr;
    uint8_t *end;
} sbuf_t;

sbuf_t *sbufInit(sbuf_t *sbuf, uint8_t *ptr, uint8_t *end);

void sbufWriteU8(sbuf_t *dst, uint8_t val);
void sbufWriteU16(sbuf_t *dst, uint16_t val);
void sbufWriteU32(sbuf_t *dst, uint32_t val);
void sbufWriteU16BigEndian(sbuf_t *dst, uint16_t val);
void sbufWriteU32BigEndian(sbuf_t *dst, uint32_t val);
void sbufFill(sbuf_t *dst, uint8_t data, int len);
void sbufWriteData(sbuf_t *dst, const void *data, int len);
void sbufWriteString(sbuf_t *dst, const char *string);
void sbufWriteStringWithZeroTerminator(sbuf_t *dst, const char *string);

uint8_t sbufReadU8(sbuf_t *src);
uint16_t sbufReadU16(sbuf_t *src);
uint32_t sbufReadU32(sbuf_t *src);
void sbufReadData(sbuf_t *dst, void *data, int len);

int sbufBytesRemaining(sbuf_t *buf);
uint8_t* sbufPtr(sbuf_t *buf);
const uint8_t* sbufConstPtr(const sbuf_t *buf);
void sbufAdvance(sbuf_t *buf, int size);

void sbufSwitchToReader(sbuf_t *buf, uint8_t * base);
# 25 "./src/main/io/rcdevice.c" 2

# 1 "./src/main/drivers/time.h" 1
# 18 "./src/main/drivers/time.h"
       



# 1 "./src/main/common/time.h" 1
# 18 "./src/main/common/time.h"
       




# 1 "./src/main/platform.h" 1
# 18 "./src/main/platform.h"
       
# 101 "./src/main/platform.h"
# 1 "./src/main/target/common_fc_pre.h" 1
# 18 "./src/main/target/common_fc_pre.h"
       





#pragma GCC diagnostic ignored "-Wsign-conversion"
# 102 "./src/main/platform.h" 2
# 1 "./src/main/target/SITL/target.h" 1
# 20 "./src/main/target/SITL/target.h"
       


# 1 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h" 1 3 4
# 149 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h" 3 4

# 149 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h" 3 4
typedef long int ptrdiff_t;
# 328 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h" 3 4
typedef int wchar_t;
# 24 "./src/main/target/SITL/target.h" 2

# 1 "./src/main/common/utils.h" 1
# 18 "./src/main/common/utils.h"
       

# 1 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h" 1 3 4
# 21 "./src/main/common/utils.h" 2
# 96 "./src/main/common/utils.h"

# 96 "./src/main/common/utils.h"
static inline int16_t cmp16(uint16_t a, uint16_t b) { return (int16_t)(a-b); }
static inline int32_t cmp32(uint32_t a, uint32_t b) { return (int32_t)(a-b); }
# 106 "./src/main/common/utils.h"
void * memcpy_fn ( void * destination, const void * source, size_t num ) asm("memcpy");
# 26 "./src/main/target/SITL/target.h" 2
# 144 "./src/main/target/SITL/target.h"
uint32_t SystemCoreClock;


extern uint8_t eepromData[32768];







typedef enum
{
    Mode_TEST = 0x0,
    Mode_Out_PP = 0x10
} GPIO_Mode;

typedef enum {RESET = 0, SET = !RESET} FlagStatus, ITStatus;
typedef enum {DISABLE = 0, ENABLE = !DISABLE} FunctionalState;
typedef enum {TEST_IRQ = 0 } IRQn_Type;
typedef enum {
    EXTI_Trigger_Rising = 0x08,
    EXTI_Trigger_Falling = 0x0C,
    EXTI_Trigger_Rising_Falling = 0x10
} EXTITrigger_TypeDef;

typedef struct
{
  uint32_t IDR;
  uint32_t ODR;
  uint32_t BSRR;
  uint32_t BRR;
} GPIO_TypeDef;



typedef struct
{
    void* test;
} TIM_TypeDef;

typedef struct
{
    void* test;
} TIM_OCInitTypeDef;

typedef struct {
    void* test;
} DMA_TypeDef;

typedef struct {
    void* test;
} DMA_Channel_TypeDef;

uint8_t DMA_GetFlagStatus(void *);
void DMA_Cmd(DMA_Channel_TypeDef*, FunctionalState );
void DMA_ClearFlag(uint32_t);

typedef struct
{
    void* test;
} SPI_TypeDef;

typedef struct
{
    void* test;
} USART_TypeDef;
# 226 "./src/main/target/SITL/target.h"
typedef struct
{
    void* test;
} I2C_TypeDef;

typedef enum
{
  FLASH_BUSY = 1,
  FLASH_ERROR_PG,
  FLASH_ERROR_WRP,
  FLASH_COMPLETE,
  FLASH_TIMEOUT
} FLASH_Status;

typedef struct {
    double timestamp;
    double imu_angular_velocity_rpy[3];
    double imu_linear_acceleration_xyz[3];
    double imu_orientation_quat[4];
    double velocity_xyz[3];
    double position_xyz[3];
} fdm_packet;
typedef struct {
    float motor_speed[4];
} servo_packet;

void FLASH_Unlock(void);
void FLASH_Lock(void);
FLASH_Status FLASH_ErasePage(uintptr_t Page_Address);
FLASH_Status FLASH_ProgramWord(uintptr_t addr, uint32_t Data);

uint64_t nanos64_real(void);
uint64_t micros64_real(void);
uint64_t millis64_real(void);
void delayMicroseconds_real(uint32_t us);
uint64_t micros64(void);
uint64_t millis64(void);

int lockMainPID(void);
# 103 "./src/main/platform.h" 2
# 1 "./src/main/target/common_fc_post.h" 1
# 20 "./src/main/target/common_fc_post.h"
       

# 1 "./src/main/build/version.h" 1
# 18 "./src/main/build/version.h"
       
# 32 "./src/main/build/version.h"
extern const char* const targetName;


extern const char* const shortGitRevision;


extern const char* const buildDate;


extern const char* const buildTime;
# 23 "./src/main/target/common_fc_post.h" 2
# 104 "./src/main/platform.h" 2
# 24 "./src/main/common/time.h" 2

# 1 "./src/main/pg/pg.h" 1
# 18 "./src/main/pg/pg.h"
       




# 1 "./src/main/build/build_config.h" 1
# 18 "./src/main/build/build_config.h"
       
# 24 "./src/main/pg/pg.h" 2

typedef uint16_t pgn_t;


typedef enum {
    PGRF_NONE = 0,
    PGRF_CLASSIFICATON_BIT = (1 << 0)
} pgRegistryFlags_e;

typedef enum {
    PGR_PGN_MASK = 0x0fff,
    PGR_PGN_VERSION_MASK = 0xf000,
    PGR_SIZE_MASK = 0x0fff,
    PGR_SIZE_SYSTEM_FLAG = 0x0000
} pgRegistryInternal_e;


typedef void (pgResetFunc)(void * , int );

typedef struct pgRegistry_s {
    pgn_t pgn;
    uint16_t size;
    uint8_t *address;
    uint8_t *copy;
    uint8_t **ptr;
    union {
        void *ptr;
        pgResetFunc *fn;
    } reset;
} pgRegistry_t;

static inline uint16_t pgN(const pgRegistry_t* reg) {return reg->pgn & PGR_PGN_MASK;}
static inline uint8_t pgVersion(const pgRegistry_t* reg) {return (uint8_t)(reg->pgn >> 12);}
static inline uint16_t pgSize(const pgRegistry_t* reg) {return reg->size & PGR_SIZE_MASK;}
# 70 "./src/main/pg/pg.h"
extern const pgRegistry_t __pg_registry_start[];
extern const pgRegistry_t __pg_registry_end[];


extern const uint8_t __pg_resetdata_start[];
extern const uint8_t __pg_resetdata_end[];
# 185 "./src/main/pg/pg.h"
const pgRegistry_t* pgFind(pgn_t pgn);

void pgLoad(const pgRegistry_t* reg, const void *from, int size, int version);
int pgStore(const pgRegistry_t* reg, void *to, int size);
void pgResetAll(void);
void pgResetInstance(const pgRegistry_t *reg, uint8_t *base);

# 191 "./src/main/pg/pg.h" 3 4
_Bool 
# 191 "./src/main/pg/pg.h"
    pgResetCopy(void *copy, pgn_t pgn);
void pgReset(const pgRegistry_t* reg);
# 26 "./src/main/common/time.h" 2


typedef int32_t timeDelta_t;

typedef uint32_t timeMs_t ;





typedef uint32_t timeUs_t;



static inline timeDelta_t cmpTimeUs(timeUs_t a, timeUs_t b) { return (timeDelta_t)(a - b); }





typedef struct timeConfig_s {
    int16_t tz_offsetMinutes;
} timeConfig_t;

extern timeConfig_t timeConfig_System; extern timeConfig_t timeConfig_Copy; static inline const timeConfig_t* timeConfig(void) { return &timeConfig_System; } static inline timeConfig_t* timeConfigMutable(void) { return &timeConfig_System; } struct _dummy;


typedef int64_t rtcTime_t;

rtcTime_t rtcTimeMake(int32_t secs, uint16_t millis);
int32_t rtcTimeGetSeconds(rtcTime_t *t);
uint16_t rtcTimeGetMillis(rtcTime_t *t);

typedef struct _dateTime_s {

    uint16_t year;

    uint8_t month;

    uint8_t day;

    uint8_t hours;

    uint8_t minutes;

    uint8_t seconds;

    uint16_t millis;
} dateTime_t;



# 77 "./src/main/common/time.h" 3 4
_Bool 
# 77 "./src/main/common/time.h"
    dateTimeFormatUTC(char *buf, dateTime_t *dt);

# 78 "./src/main/common/time.h" 3 4
_Bool 
# 78 "./src/main/common/time.h"
    dateTimeFormatLocal(char *buf, dateTime_t *dt);

# 79 "./src/main/common/time.h" 3 4
_Bool 
# 79 "./src/main/common/time.h"
    dateTimeFormatLocalShort(char *buf, dateTime_t *dt);

void dateTimeUTCToLocal(dateTime_t *utcDateTime, dateTime_t *localDateTime);




# 85 "./src/main/common/time.h" 3 4
_Bool 
# 85 "./src/main/common/time.h"
    dateTimeSplitFormatted(char *formatted, char **date, char **time);


# 87 "./src/main/common/time.h" 3 4
_Bool 
# 87 "./src/main/common/time.h"
    rtcHasTime(void);


# 89 "./src/main/common/time.h" 3 4
_Bool 
# 89 "./src/main/common/time.h"
    rtcGet(rtcTime_t *t);

# 90 "./src/main/common/time.h" 3 4
_Bool 
# 90 "./src/main/common/time.h"
    rtcSet(rtcTime_t *t);


# 92 "./src/main/common/time.h" 3 4
_Bool 
# 92 "./src/main/common/time.h"
    rtcGetDateTime(dateTime_t *dt);

# 93 "./src/main/common/time.h" 3 4
_Bool 
# 93 "./src/main/common/time.h"
    rtcSetDateTime(dateTime_t *dt);
# 23 "./src/main/drivers/time.h" 2

void delayMicroseconds(timeUs_t us);
void delay(timeMs_t ms);

timeUs_t micros(void);
timeUs_t microsISR(void);
timeMs_t millis(void);

uint32_t ticks(void);
timeDelta_t ticks_diff_us(uint32_t begin, uint32_t end);
# 27 "./src/main/io/rcdevice.c" 2

# 1 "./src/main/io/serial.h" 1
# 18 "./src/main/io/serial.h"
       





# 1 "./src/main/drivers/serial.h" 1
# 18 "./src/main/drivers/serial.h"
       

# 1 "./src/main/drivers/io.h" 1
# 18 "./src/main/drivers/io.h"
       






# 1 "./src/main/drivers/resource.h" 1
# 18 "./src/main/drivers/resource.h"
       

typedef enum {
    OWNER_FREE = 0,
    OWNER_PWMINPUT,
    OWNER_PPMINPUT,
    OWNER_MOTOR,
    OWNER_SERVO,
    OWNER_LED,
    OWNER_ADC,
    OWNER_ADC_BATT,
    OWNER_ADC_CURR,
    OWNER_ADC_EXT,
    OWNER_ADC_RSSI,
    OWNER_SERIAL_TX,
    OWNER_SERIAL_RX,
    OWNER_PINDEBUG,
    OWNER_TIMER,
    OWNER_SONAR_TRIGGER,
    OWNER_SONAR_ECHO,
    OWNER_SYSTEM,
    OWNER_SPI_SCK,
    OWNER_SPI_MISO,
    OWNER_SPI_MOSI,
    OWNER_I2C_SCL,
    OWNER_I2C_SDA,
    OWNER_SDCARD,
    OWNER_SDCARD_CS,
    OWNER_SDCARD_DETECT,
    OWNER_FLASH_CS,
    OWNER_BARO_CS,
    OWNER_MPU_CS,
    OWNER_OSD_CS,
    OWNER_RX_SPI_CS,
    OWNER_SPI_CS,
    OWNER_MPU_EXTI,
    OWNER_BARO_EXTI,
    OWNER_COMPASS_EXTI,
    OWNER_USB,
    OWNER_USB_DETECT,
    OWNER_BEEPER,
    OWNER_OSD,
    OWNER_RX_BIND,
    OWNER_INVERTER,
    OWNER_LED_STRIP,
    OWNER_TRANSPONDER,
    OWNER_VTX,
    OWNER_COMPASS_CS,
    OWNER_SPI_PREINIT,
    OWNER_RX_BIND_PLUG,
    OWNER_ESCSERIAL,
    OWNER_CAMERA_CONTROL,
    OWNER_TIMUP,
    OWNER_RANGEFINDER,
    OWNER_RX_SPI,
    OWNER_PINIO,
    OWNER_TOTAL_COUNT
} resourceOwner_e;

extern const char * const ownerNames[OWNER_TOTAL_COUNT];
# 26 "./src/main/drivers/io.h" 2

# 1 "./src/main/drivers/io_types.h" 1
# 18 "./src/main/drivers/io_types.h"
        





typedef uint8_t ioTag_t;
typedef void* IO_t;
# 45 "./src/main/drivers/io_types.h"
typedef uint8_t ioConfig_t;
# 28 "./src/main/drivers/io.h" 2
# 99 "./src/main/drivers/io.h"
# 1 "./src/main/drivers/io_def.h" 1
# 18 "./src/main/drivers/io_def.h"
       
# 51 "./src/main/drivers/io_def.h"
# 1 "./src/main/drivers/io_def_generated.h" 1
# 18 "./src/main/drivers/io_def_generated.h"
       
# 51 "./src/main/drivers/io_def.h" 2
# 100 "./src/main/drivers/io.h" 2


# 101 "./src/main/drivers/io.h" 3 4
_Bool 
# 101 "./src/main/drivers/io.h"
    IORead(IO_t io);
void IOWrite(IO_t io, 
# 102 "./src/main/drivers/io.h" 3 4
                     _Bool 
# 102 "./src/main/drivers/io.h"
                          value);
void IOHi(IO_t io);
void IOLo(IO_t io);
void IOToggle(IO_t io);

void IOInit(IO_t io, resourceOwner_e owner, uint8_t index);
void IORelease(IO_t io);
resourceOwner_e IOGetOwner(IO_t io);
IO_t IOGetByTag(ioTag_t tag);

void IOConfigGPIO(IO_t io, ioConfig_t cfg);




void IOInitGlobal(void);
# 21 "./src/main/drivers/serial.h" 2


typedef enum {
    MODE_RX = 1 << 0,
    MODE_TX = 1 << 1,
    MODE_RXTX = MODE_RX | MODE_TX
} portMode_e;

typedef enum {
    SERIAL_NOT_INVERTED = 0 << 0,
    SERIAL_INVERTED = 1 << 0,
    SERIAL_STOPBITS_1 = 0 << 1,
    SERIAL_STOPBITS_2 = 1 << 1,
    SERIAL_PARITY_NO = 0 << 2,
    SERIAL_PARITY_EVEN = 1 << 2,
    SERIAL_UNIDIR = 0 << 3,
    SERIAL_BIDIR = 1 << 3,
# 46 "./src/main/drivers/serial.h"
    SERIAL_BIDIR_OD = 0 << 4,
    SERIAL_BIDIR_PP = 1 << 4,
    SERIAL_BIDIR_NOPULL = 1 << 5,
} portOptions_e;

typedef void (*serialReceiveCallbackPtr)(uint16_t data, void *rxCallbackData);

typedef struct serialPort_s {

    const struct serialPortVTable *vTable;

    uint8_t identifier;
    portMode_e mode;
    portOptions_e options;

    uint32_t baudRate;

    uint32_t rxBufferSize;
    uint32_t txBufferSize;
    volatile uint8_t *rxBuffer;
    volatile uint8_t *txBuffer;
    uint32_t rxBufferHead;
    uint32_t rxBufferTail;
    uint32_t txBufferHead;
    uint32_t txBufferTail;

    serialReceiveCallbackPtr rxCallback;
    void *rxCallbackData;
} serialPort_t;
# 86 "./src/main/drivers/serial.h"
typedef struct serialPinConfig_s {
    ioTag_t ioTagTx[10];
    ioTag_t ioTagRx[10];
    ioTag_t ioTagInverter[10];
} serialPinConfig_t;

extern serialPinConfig_t serialPinConfig_System; extern serialPinConfig_t serialPinConfig_Copy; static inline const serialPinConfig_t* serialPinConfig(void) { return &serialPinConfig_System; } static inline serialPinConfig_t* serialPinConfigMutable(void) { return &serialPinConfig_System; } struct _dummy;

struct serialPortVTable {
    void (*serialWrite)(serialPort_t *instance, uint8_t ch);

    uint32_t (*serialTotalRxWaiting)(const serialPort_t *instance);
    uint32_t (*serialTotalTxFree)(const serialPort_t *instance);

    uint8_t (*serialRead)(serialPort_t *instance);


    void (*serialSetBaudRate)(serialPort_t *instance, uint32_t baudRate);

    
# 105 "./src/main/drivers/serial.h" 3 4
   _Bool 
# 105 "./src/main/drivers/serial.h"
        (*isSerialTransmitBufferEmpty)(const serialPort_t *instance);

    void (*setMode)(serialPort_t *instance, portMode_e mode);

    void (*writeBuf)(serialPort_t *instance, const void *data, int count);

    void (*beginWrite)(serialPort_t *instance);
    void (*endWrite)(serialPort_t *instance);
};

void serialWrite(serialPort_t *instance, uint8_t ch);
uint32_t serialRxBytesWaiting(const serialPort_t *instance);
uint32_t serialTxBytesFree(const serialPort_t *instance);
void serialWriteBuf(serialPort_t *instance, const uint8_t *data, int count);
uint8_t serialRead(serialPort_t *instance);
void serialSetBaudRate(serialPort_t *instance, uint32_t baudRate);
void serialSetMode(serialPort_t *instance, portMode_e mode);

# 122 "./src/main/drivers/serial.h" 3 4
_Bool 
# 122 "./src/main/drivers/serial.h"
    isSerialTransmitBufferEmpty(const serialPort_t *instance);
void serialPrint(serialPort_t *instance, const char *str);
uint32_t serialGetBaudRate(serialPort_t *instance);


void serialWriteBufShim(void *instance, const uint8_t *data, int count);
void serialBeginWrite(serialPort_t *instance);
void serialEndWrite(serialPort_t *instance);
# 25 "./src/main/io/serial.h" 2

typedef enum {
    PORTSHARING_UNUSED = 0,
    PORTSHARING_NOT_SHARED,
    PORTSHARING_SHARED
} portSharing_e;

typedef enum {
    FUNCTION_NONE = 0,
    FUNCTION_MSP = (1 << 0),
    FUNCTION_GPS = (1 << 1),
    FUNCTION_TELEMETRY_FRSKY_HUB = (1 << 2),
    FUNCTION_TELEMETRY_HOTT = (1 << 3),
    FUNCTION_TELEMETRY_LTM = (1 << 4),
    FUNCTION_TELEMETRY_SMARTPORT = (1 << 5),
    FUNCTION_RX_SERIAL = (1 << 6),
    FUNCTION_BLACKBOX = (1 << 7),
    FUNCTION_TELEMETRY_MAVLINK = (1 << 9),
    FUNCTION_ESC_SENSOR = (1 << 10),
    FUNCTION_VTX_SMARTAUDIO = (1 << 11),
    FUNCTION_TELEMETRY_IBUS = (1 << 12),
    FUNCTION_VTX_TRAMP = (1 << 13),
    FUNCTION_RCDEVICE = (1 << 14),
    FUNCTION_LIDAR_TF = (1 << 15),
} serialPortFunction_e;

typedef enum {
    BAUD_AUTO = 0,
    BAUD_9600,
    BAUD_19200,
    BAUD_38400,
    BAUD_57600,
    BAUD_115200,
    BAUD_230400,
    BAUD_250000,
    BAUD_400000,
    BAUD_460800,
    BAUD_500000,
    BAUD_921600,
    BAUD_1000000,
    BAUD_1500000,
    BAUD_2000000,
    BAUD_2470000
} baudRate_e;

extern const uint32_t baudRates[];


typedef enum {
    SERIAL_PORT_NONE = -1,
    SERIAL_PORT_USART1 = 0,
    SERIAL_PORT_USART2,
    SERIAL_PORT_USART3,
    SERIAL_PORT_UART4,
    SERIAL_PORT_UART5,
    SERIAL_PORT_USART6,
    SERIAL_PORT_USART7,
    SERIAL_PORT_USART8,
    SERIAL_PORT_USB_VCP = 20,
    SERIAL_PORT_SOFTSERIAL1 = 30,
    SERIAL_PORT_SOFTSERIAL2
} serialPortIdentifier_e;

extern const serialPortIdentifier_e serialPortIdentifiers[8];
# 97 "./src/main/io/serial.h"
typedef struct serialPortUsage_s {
    serialPort_t *serialPort;
    serialPortFunction_e function;
    serialPortIdentifier_e identifier;
} serialPortUsage_t;

serialPort_t *findSharedSerialPort(uint16_t functionMask, serialPortFunction_e sharedWithFunction);
serialPort_t *findNextSharedSerialPort(uint16_t functionMask, serialPortFunction_e sharedWithFunction);




typedef struct serialPortConfig_s {
    uint16_t functionMask;
    serialPortIdentifier_e identifier;
    uint8_t msp_baudrateIndex;
    uint8_t gps_baudrateIndex;
    uint8_t blackbox_baudrateIndex;
    uint8_t telemetry_baudrateIndex;
} serialPortConfig_t;

typedef struct serialConfig_s {
    serialPortConfig_t portConfigs[8];
    uint16_t serial_update_rate_hz;
    uint8_t reboot_character;
} serialConfig_t;

extern serialConfig_t serialConfig_System; extern serialConfig_t serialConfig_Copy; static inline const serialConfig_t* serialConfig(void) { return &serialConfig_System; } static inline serialConfig_t* serialConfigMutable(void) { return &serialConfig_System; } struct _dummy;

typedef void serialConsumer(uint8_t);




void serialInit(
# 131 "./src/main/io/serial.h" 3 4
               _Bool 
# 131 "./src/main/io/serial.h"
                    softserialEnabled, serialPortIdentifier_e serialPortToDisable);
void serialRemovePort(serialPortIdentifier_e identifier);
uint8_t serialGetAvailablePortCount(void);

# 134 "./src/main/io/serial.h" 3 4
_Bool 
# 134 "./src/main/io/serial.h"
    serialIsPortAvailable(serialPortIdentifier_e identifier);

# 135 "./src/main/io/serial.h" 3 4
_Bool 
# 135 "./src/main/io/serial.h"
    isSerialConfigValid(const serialConfig_t *serialConfig);
serialPortConfig_t *serialFindPortConfiguration(serialPortIdentifier_e identifier);

# 137 "./src/main/io/serial.h" 3 4
_Bool 
# 137 "./src/main/io/serial.h"
    doesConfigurationUsePort(serialPortIdentifier_e portIdentifier);
serialPortConfig_t *findSerialPortConfig(serialPortFunction_e function);
serialPortConfig_t *findNextSerialPortConfig(serialPortFunction_e function);

portSharing_e determinePortSharing(const serialPortConfig_t *portConfig, serialPortFunction_e function);

# 142 "./src/main/io/serial.h" 3 4
_Bool 
# 142 "./src/main/io/serial.h"
    isSerialPortShared(const serialPortConfig_t *portConfig, uint16_t functionMask, serialPortFunction_e sharedWithFunction);

void pgResetFn_serialConfig(serialConfig_t *serialConfig);
serialPortUsage_t *findSerialPortUsageByIdentifier(serialPortIdentifier_e identifier);
int findSerialPortIndexByIdentifier(serialPortIdentifier_e identifier);



serialPort_t *openSerialPort(
    serialPortIdentifier_e identifier,
    serialPortFunction_e function,
    serialReceiveCallbackPtr rxCallback,
    void *rxCallbackData,
    uint32_t baudrate,
    portMode_e mode,
    portOptions_e options
);
void closeSerialPort(serialPort_t *serialPort);

void waitForSerialPortToFinishTransmitting(serialPort_t *serialPort);

baudRate_e lookupBaudRateIndex(uint32_t baudRate);





void serialPassthrough(serialPort_t *left, serialPort_t *right, serialConsumer *leftC, serialConsumer *rightC);
# 29 "./src/main/io/rcdevice.c" 2

# 1 "./src/main/io/rcdevice.h" 1
# 18 "./src/main/io/rcdevice.h"
       
# 58 "./src/main/io/rcdevice.h"
typedef enum {
    RCDEVICE_PROTOCOL_FEATURE_SIMULATE_POWER_BUTTON = (1 << 0),
    RCDEVICE_PROTOCOL_FEATURE_SIMULATE_WIFI_BUTTON = (1 << 1),
    RCDEVICE_PROTOCOL_FEATURE_CHANGE_MODE = (1 << 2),
    RCDEVICE_PROTOCOL_FEATURE_SIMULATE_5_KEY_OSD_CABLE = (1 << 3),
    RCDEVICE_PROTOCOL_FEATURE_DEVICE_SETTINGS_ACCESS = (1 << 4),
    RCDEVICE_PROTOCOL_FEATURE_DISPLAYP_PORT = (1 << 5),
    RCDEVICE_PROTOCOL_FEATURE_START_RECORDING = (1 << 6),
    RCDEVICE_PROTOCOL_FEATURE_STOP_RECORDING = (1 << 7),
    RCDEVICE_PROTOCOL_FEATURE_CMS_MENU = (1 << 8),
} rcdevice_features_e;


typedef enum {
    RCDEVICE_PROTOCOL_CAM_CTRL_SIMULATE_WIFI_BTN = 0x00,
    RCDEVICE_PROTOCOL_CAM_CTRL_SIMULATE_POWER_BTN = 0x01,
    RCDEVICE_PROTOCOL_CAM_CTRL_CHANGE_MODE = 0x02,
    RCDEVICE_PROTOCOL_CAM_CTRL_START_RECORDING = 0x03,
    RCDEVICE_PROTOCOL_CAM_CTRL_STOP_RECORDING = 0x04,
    RCDEVICE_PROTOCOL_CAM_CTRL_UNKNOWN_CAMERA_OPERATION = 0xFF
} rcdevice_camera_control_opeation_e;


typedef enum {
    RCDEVICE_PROTOCOL_5KEY_SIMULATION_NONE = 0x00,
    RCDEVICE_PROTOCOL_5KEY_SIMULATION_SET = 0x01,
    RCDEVICE_PROTOCOL_5KEY_SIMULATION_LEFT = 0x02,
    RCDEVICE_PROTOCOL_5KEY_SIMULATION_RIGHT = 0x03,
    RCDEVICE_PROTOCOL_5KEY_SIMULATION_UP = 0x04,
    RCDEVICE_PROTOCOL_5KEY_SIMULATION_DOWN = 0x05
} rcdevice_5key_simulation_operation_e;


typedef enum {
    RCDEVICE_PROTOCOL_5KEY_CONNECTION_OPEN = 0x01,
    RCDEVICE_PROTOCOL_5KEY_CONNECTION_CLOSE = 0x02
} RCDEVICE_5key_connection_event_e;

typedef enum {
    RCDEVICE_CAM_KEY_NONE,
    RCDEVICE_CAM_KEY_ENTER,
    RCDEVICE_CAM_KEY_LEFT,
    RCDEVICE_CAM_KEY_UP,
    RCDEVICE_CAM_KEY_RIGHT,
    RCDEVICE_CAM_KEY_DOWN,
    RCDEVICE_CAM_KEY_CONNECTION_CLOSE,
    RCDEVICE_CAM_KEY_CONNECTION_OPEN,
    RCDEVICE_CAM_KEY_RELEASE,
} rcdeviceCamSimulationKeyEvent_e;

typedef enum {
    RCDEVICE_PROTOCOL_RCSPLIT_VERSION = 0x00,


    RCDEVICE_PROTOCOL_VERSION_1_0 = 0x01,
    RCDEVICE_PROTOCOL_UNKNOWN
} rcdevice_protocol_version_e;


typedef enum {
    RCDEVICE_PROTOCOL_SETTINGID_DISP_CHARSET = 0,

    RCDEVICE_PROTOCOL_SETTINGID_DISP_COLUMNS = 1,
    RCDEVICE_PROTOCOL_SETTINGID_DISP_TV_MODE = 2,
    RCDEVICE_PROTOCOL_SETTINGID_SDCARD_CAPACITY = 3,
    RCDEVICE_PROTOCOL_SETTINGID_REMAINING_RECORDING_TIME = 4,
    RCDEVICE_PROTOCOL_SETTINGID_RESOLUTION = 5,
    RCDEVICE_PROTOCOL_SETTINGID_CAMERA_TIME = 6,
    RCDEVICE_PROTOCOL_SETTINGID_RESERVED7 = 7,
    RCDEVICE_PROTOCOL_SETTINGID_RESERVED8 = 8,
    RCDEVICE_PROTOCOL_SETTINGID_RESERVED9 = 9,
    RCDEVICE_PROTOCOL_SETTINGID_RESERVED10 = 10,
    RCDEVICE_PROTOCOL_SETTINGID_RESERVED11 = 11,
    RCDEVICE_PROTOCOL_SETTINGID_RESERVED12 = 12,
    RCDEVICE_PROTOCOL_SETTINGID_RESERVED13 = 13,
    RCDEVICE_PROTOCOL_SETTINGID_RESERVED14 = 14,
    RCDEVICE_PROTOCOL_SETTINGID_RESERVED15 = 15,
    RCDEVICE_PROTOCOL_SETTINGID_RESERVED16 = 16,
    RCDEVICE_PROTOCOL_SETTINGID_RESERVED17 = 17,
    RCDEVICE_PROTOCOL_SETTINGID_RESERVED18 = 18,
    RCDEVICE_PROTOCOL_SETTINGID_RESERVED19 = 19,
} rcdeviceReservedSettingID_e;

typedef enum {
    RCDEVICE_PROTOCOL_SETTINGTYPE_UINT8 = 0,
    RCDEVICE_PROTOCOL_SETTINGTYPE_INT8 = 1,
    RCDEVICE_PROTOCOL_SETTINGTYPE_UINT16 = 2,
    RCDEVICE_PROTOCOL_SETTINGTYPE_INT16 = 3,
    RCDEVICE_PROTOCOL_SETTINGTYPE_FLOAT = 8,
    RCDEVICE_PROTOCOL_SETTINGTYPE_TEXT_SELECTION = 9,
    RCDEVICE_PROTOCOL_SETTINGTYPE_STRING = 10,
    RCDEVICE_PROTOCOL_SETTINGTYPE_FOLDER = 11,
    RCDEVICE_PROTOCOL_SETTINGTYPE_INFO = 12,
    RCDEVICE_PROTOCOL_SETTINGTYPE_UNKNOWN
} rcdeviceSettingType_e;

typedef enum {
    RCDEVICE_SUCCEED = 0,
    RCDEVICE_INVALID = 1,
    RCDEVICE_NODEV = 2,
    RCDEVICE_DEVBUSY = 3,
} rcdeviceErrorCode_e;
# 171 "./src/main/io/rcdevice.h"
typedef enum {
    RCSPLIT_CTRL_ARGU_INVALID = 0x0,
    RCSPLIT_CTRL_ARGU_WIFI_BTN = 0x1,
    RCSPLIT_CTRL_ARGU_POWER_BTN = 0x2,
    RCSPLIT_CTRL_ARGU_CHANGE_MODE = 0x3,
    RCSPLIT_CTRL_ARGU_WHO_ARE_YOU = 0xFF,
} rcsplit_ctrl_argument_e;


typedef struct runcamDeviceInfo_s {
    rcdevice_protocol_version_e protocolVersion;
    uint16_t features;
} runcamDeviceInfo_t;

typedef struct runcamDeviceSetting_s {
    uint8_t id;
    char name[20];
    char value[20];
} runcamDeviceSetting_t;

typedef struct runcamDeviceSettingTextSelection_s {
    char text[20];
} runcamDeviceSettingTextSelection_t;

typedef struct runcamDeviceSettingDetail_s {
    uint8_t type;
    uint32_t value;
    uint32_t minValue;
    uint32_t maxValue;
    uint8_t decimalPoint;
    uint32_t stepSize;
    uint8_t maxStringSize;
    char stringValue[58];
    runcamDeviceSettingTextSelection_t textSelections[30];
} runcamDeviceSettingDetail_t;

typedef struct runcamDeviceWriteSettingResponse_s {
    uint8_t resultCode;
    uint8_t needUpdateMenuItems;
} runcamDeviceWriteSettingResponse_t;

typedef struct runcamDevice_s {
    serialPort_t *serialPort;
    uint8_t buffer[64];
    runcamDeviceInfo_t info;
} runcamDevice_t;


# 218 "./src/main/io/rcdevice.h" 3 4
_Bool 
# 218 "./src/main/io/rcdevice.h"
    runcamDeviceInit(runcamDevice_t *device);



# 221 "./src/main/io/rcdevice.h" 3 4
_Bool 
# 221 "./src/main/io/rcdevice.h"
    runcamDeviceSimulateCameraButton(runcamDevice_t *device, uint8_t operation);



# 224 "./src/main/io/rcdevice.h" 3 4
_Bool 
# 224 "./src/main/io/rcdevice.h"
    runcamDeviceOpen5KeyOSDCableConnection(runcamDevice_t *device);

# 225 "./src/main/io/rcdevice.h" 3 4
_Bool 
# 225 "./src/main/io/rcdevice.h"
    runcamDeviceClose5KeyOSDCableConnection(runcamDevice_t *device, uint8_t *resultCode);

# 226 "./src/main/io/rcdevice.h" 3 4
_Bool 
# 226 "./src/main/io/rcdevice.h"
    runcamDeviceSimulate5KeyOSDCableButtonPress(runcamDevice_t *device, uint8_t operation);

# 227 "./src/main/io/rcdevice.h" 3 4
_Bool 
# 227 "./src/main/io/rcdevice.h"
    runcamDeviceSimulate5KeyOSDCableButtonRelease(runcamDevice_t *device);


void runcamDeviceDispFillRegion(runcamDevice_t *device, uint8_t x, uint8_t y, uint8_t width, uint8_t height, uint8_t c);
void runcamDeviceDispWriteChar(runcamDevice_t *device, uint8_t x, uint8_t y, uint8_t c);
void runcamDeviceDispWriteHorizontalString(runcamDevice_t *device, uint8_t x, uint8_t y, const char *text);
void runcamDeviceDispWriteVerticalString(runcamDevice_t *device, uint8_t x, uint8_t y, const char *text);
void runcamDeviceDispWriteChars(runcamDevice_t *device, uint8_t *data, uint8_t datalen);



# 237 "./src/main/io/rcdevice.h" 3 4
_Bool 
# 237 "./src/main/io/rcdevice.h"
    runcamDeviceGetSettings(runcamDevice_t *device, uint8_t parentSettingID, runcamDeviceSetting_t *outSettingList, int maxSettingItemCount);

# 238 "./src/main/io/rcdevice.h" 3 4
_Bool 
# 238 "./src/main/io/rcdevice.h"
    runcamDeviceGetSettingDetail(runcamDevice_t *device, uint8_t settingID, runcamDeviceSettingDetail_t *outSettingDetail);

# 239 "./src/main/io/rcdevice.h" 3 4
_Bool 
# 239 "./src/main/io/rcdevice.h"
    runcamDeviceWriteSetting(runcamDevice_t *device, uint8_t settingID, uint8_t *data, uint8_t dataLen, runcamDeviceWriteSettingResponse_t *response);
# 31 "./src/main/io/rcdevice.c" 2



typedef enum {
    RCDP_SETTING_PARSE_WAITING_ID,
    RCDP_SETTING_PARSE_WAITING_NAME,
    RCDP_SETTING_PARSE_WAITING_VALUE,
} runcamDeviceSettingParseStep_e;

typedef struct runcamDeviceExpectedResponseLength_s {
    uint8_t command;
    uint8_t reponseLength;
} runcamDeviceExpectedResponseLength_t;

static runcamDeviceExpectedResponseLength_t expectedResponsesLength[] = {
    { 0x10, 0xFF},
    { 0x11, 0xFF},
    { 0x00, 5},
    { 0x02, 2},
    { 0x03, 2},
    { 0x04, 3},
    { 0x13, 4},
};

static uint8_t runcamDeviceGetResponseLength(uint8_t command)
{
    for (unsigned int i = 0; i < (sizeof(expectedResponsesLength) / sizeof((expectedResponsesLength)[0])); i++) {
        if (expectedResponsesLength[i].command == command) {
            return expectedResponsesLength[i].reponseLength;
        }
    }

    return 0;
}



static uint8_t runcamDeviceIsResponseReceiveDone(uint8_t command, uint8_t *data, uint8_t dataLen, 
# 68 "./src/main/io/rcdevice.c" 3 4
                                                                                                 _Bool 
# 68 "./src/main/io/rcdevice.c"
                                                                                                      *isDone)
{
    uint8_t expectedResponseDataLength = runcamDeviceGetResponseLength(command);
    if (expectedResponseDataLength == 0xFF) {
        uint8_t settingDataLength = 0x00;

        if (dataLen >= 3) {
            settingDataLength = data[2];
            if (dataLen >= (settingDataLength + 4)) {
                *isDone = 
# 77 "./src/main/io/rcdevice.c" 3 4
                         1
# 77 "./src/main/io/rcdevice.c"
                             ;
                return 
# 78 "./src/main/io/rcdevice.c" 3 4
                      1
# 78 "./src/main/io/rcdevice.c"
                          ;
            }
        }

        if (settingDataLength > 60) {
            return 
# 83 "./src/main/io/rcdevice.c" 3 4
                  0
# 83 "./src/main/io/rcdevice.c"
                       ;
        }
    } else if (dataLen >= expectedResponseDataLength) {
        *isDone = 
# 86 "./src/main/io/rcdevice.c" 3 4
                 1
# 86 "./src/main/io/rcdevice.c"
                     ;
        return 
# 87 "./src/main/io/rcdevice.c" 3 4
              1
# 87 "./src/main/io/rcdevice.c"
                  ;
    }
    return 
# 89 "./src/main/io/rcdevice.c" 3 4
          1
# 89 "./src/main/io/rcdevice.c"
              ;
}


static uint8_t runcamDeviceReceivePacket(runcamDevice_t *device, uint8_t command, uint8_t *data, int timeoutms)
{
    uint8_t dataPos = 0;
    uint8_t crc = 0;
    uint8_t responseDataLen = 0;


    timeMs_t timeout = millis() + timeoutms;
    
# 101 "./src/main/io/rcdevice.c" 3 4
   _Bool 
# 101 "./src/main/io/rcdevice.c"
        isWaitingHeader = 
# 101 "./src/main/io/rcdevice.c" 3 4
                          1
# 101 "./src/main/io/rcdevice.c"
                              ;
    while (millis() < timeout) {
        if (serialRxBytesWaiting(device->serialPort) > 0) {
            uint8_t c = serialRead(device->serialPort);
            crc = crc8_dvb_s2(crc, c);

            if (data) {
                data[dataPos] = c;
            }
            dataPos++;

            if (isWaitingHeader) {
                if (c == 0xCC) {
                    isWaitingHeader = 
# 114 "./src/main/io/rcdevice.c" 3 4
                                     0
# 114 "./src/main/io/rcdevice.c"
                                          ;
                }
            } else {
                
# 117 "./src/main/io/rcdevice.c" 3 4
               _Bool 
# 117 "./src/main/io/rcdevice.c"
                    isDone = 
# 117 "./src/main/io/rcdevice.c" 3 4
                             0
# 117 "./src/main/io/rcdevice.c"
                                  ;
                if (!runcamDeviceIsResponseReceiveDone(command, data, dataPos, &isDone)) {
                    return 0;
                }

                if (isDone) {
                    responseDataLen = dataPos;
                    break;
                }
            }
        }
    }


    if (crc != 0) {
        return 0;
    }

    return responseDataLen;
}





static void runcamDeviceFlushRxBuffer(runcamDevice_t *device)
{
    while (serialRxBytesWaiting(device->serialPort) > 0) {
        serialRead(device->serialPort);
    }
}


static void runcamDeviceSendPacket(runcamDevice_t *device, uint8_t command, uint8_t *paramData, int paramDataLen)
{

    if (!device->serialPort) {
        return;
    }

    sbuf_t buf;

    buf.ptr = device->buffer;
    buf.end = (&(device->buffer)[(sizeof(device->buffer) / sizeof((device->buffer)[0]))]);

    sbufWriteU8(&buf, 0xCC);
    sbufWriteU8(&buf, command);

    if (paramData) {
        sbufWriteData(&buf, paramData, paramDataLen);
    }


    crc8_dvb_s2_sbuf_append(&buf, device->buffer);


    sbufSwitchToReader(&buf, device->buffer);


    serialWriteBuf(device->serialPort, sbufPtr(&buf), sbufBytesRemaining(&buf));
}


static 
# 180 "./src/main/io/rcdevice.c" 3 4
      _Bool 
# 180 "./src/main/io/rcdevice.c"
           runcamDeviceSendRequestAndWaitingResp(runcamDevice_t *device, uint8_t commandID, uint8_t *paramData, uint8_t paramDataLen, uint8_t *outputBuffer, uint8_t *outputBufferLen)
{
    int max_retries = 1;


    int timeoutMs = 1000;



    if (commandID == 0x00) {
        max_retries = 5;
        timeoutMs = 60;
    }

    for (int i = 0; i < max_retries; i++) {

        runcamDeviceFlushRxBuffer(device);


        runcamDeviceSendPacket(device, commandID, paramData, paramDataLen);


        uint8_t responseLength = runcamDeviceReceivePacket(device, commandID, outputBuffer, timeoutMs);
        if (responseLength) {
            if (outputBufferLen) {
                *outputBufferLen = responseLength;
            }

            return 
# 208 "./src/main/io/rcdevice.c" 3 4
                  1
# 208 "./src/main/io/rcdevice.c"
                      ;
        }
    }

    return 
# 212 "./src/main/io/rcdevice.c" 3 4
          0
# 212 "./src/main/io/rcdevice.c"
               ;
}

static uint8_t calcCRCFromData(uint8_t *ptr, uint8_t len)
{
    uint8_t i;
    uint8_t crc = 0x00;
    while (len--) {
        crc ^= *ptr++;
        for (i = 8; i > 0; --i) {
            if (crc & 0x80) {
                crc = (crc << 1) ^ 0x31;
            } else {
                crc = (crc << 1);
            }
        }
    }
    return crc;
}

static void sendCtrlCommand(runcamDevice_t *device, rcsplit_ctrl_argument_e argument)
{
    if (!device->serialPort) {
        return ;
    }

    uint8_t uart_buffer[5] = {0};
    uint8_t crc = 0;

    uart_buffer[0] = 0x55;
    uart_buffer[1] = 0x01;
    uart_buffer[2] = argument;
    uart_buffer[3] = 0xaa;
    crc = calcCRCFromData(uart_buffer, 4);


    uart_buffer[3] = crc;
    uart_buffer[4] = 0xaa;


    serialWriteBuf(device->serialPort, uart_buffer, 5);
}



static 
# 257 "./src/main/io/rcdevice.c" 3 4
      _Bool 
# 257 "./src/main/io/rcdevice.c"
           runcamDeviceGetDeviceInfo(runcamDevice_t *device, uint8_t *outputBuffer)
{

    int max_retries = 2;
    for (int i = 0; i < max_retries; i++) {
        runcamDeviceFlushRxBuffer(device);
        sendCtrlCommand(device, RCSPLIT_CTRL_ARGU_WHO_ARE_YOU);

        timeMs_t timeout = millis() + 500;
        uint8_t response[5] = { 0 };
        while (millis() < timeout) {
            if (serialRxBytesWaiting(device->serialPort) >= 5) {
                response[0] = serialRead(device->serialPort);
                response[1] = serialRead(device->serialPort);
                response[2] = serialRead(device->serialPort);
                response[3] = serialRead(device->serialPort);
                response[4] = serialRead(device->serialPort);
                if (response[0] != 0x55 || response[1] != 0x01 || response[2] != RCSPLIT_CTRL_ARGU_WHO_ARE_YOU || response[4] != 0xaa) {
                    break;
                }

                uint8_t crcFromPacket = response[3];
                response[3] = response[4];
                uint8_t crc = calcCRCFromData(response, 4);
                if (crc != crcFromPacket) {
                    break;
                }


                outputBuffer[0] = 0xCC;

                outputBuffer[1] = RCDEVICE_PROTOCOL_RCSPLIT_VERSION;

                outputBuffer[2] = RCDEVICE_PROTOCOL_FEATURE_SIMULATE_POWER_BUTTON | RCDEVICE_PROTOCOL_FEATURE_SIMULATE_WIFI_BUTTON | RCDEVICE_PROTOCOL_FEATURE_CHANGE_MODE;
                outputBuffer[3] = 0;

                crc = 0;
                const uint8_t * const end = outputBuffer + 4;
                for (const uint8_t *ptr = outputBuffer; ptr < end; ++ptr) {
                    crc = crc8_dvb_s2(crc, *ptr);
                }
                outputBuffer[4] = crc;
                return 
# 299 "./src/main/io/rcdevice.c" 3 4
                      1
# 299 "./src/main/io/rcdevice.c"
                          ;
            }
        }
    }

    return runcamDeviceSendRequestAndWaitingResp(device, 0x00, 
# 304 "./src/main/io/rcdevice.c" 3 4
                                                                                                   ((void *)0)
# 304 "./src/main/io/rcdevice.c"
                                                                                                       , 0, outputBuffer, 
# 304 "./src/main/io/rcdevice.c" 3 4
                                                                                                                          ((void *)0)
# 304 "./src/main/io/rcdevice.c"
                                                                                                                              );
}

static 
# 307 "./src/main/io/rcdevice.c" 3 4
      _Bool 
# 307 "./src/main/io/rcdevice.c"
           runcamDeviceSend5KeyOSDCableConnectionEvent(runcamDevice_t *device, uint8_t operation, uint8_t *outActionID, uint8_t *outErrorCode)
{
    uint8_t outputDataLen = 64;
    uint8_t respBuf[64];
    if (!runcamDeviceSendRequestAndWaitingResp(device, 0x04, &operation, sizeof(uint8_t), respBuf, &outputDataLen)) {
        return 
# 312 "./src/main/io/rcdevice.c" 3 4
              0
# 312 "./src/main/io/rcdevice.c"
                   ;
    }



    uint8_t operationID = (respBuf[1] & 0xF0) >> 4;
    
# 318 "./src/main/io/rcdevice.c" 3 4
   _Bool 
# 318 "./src/main/io/rcdevice.c"
        errorCode = (respBuf[1] & 0x0F);
    if (outActionID) {
        *outActionID = operationID;
    }

    if (outErrorCode) {
        *outErrorCode = errorCode;
    }

    return 
# 327 "./src/main/io/rcdevice.c" 3 4
          1
# 327 "./src/main/io/rcdevice.c"
              ;
}






# 334 "./src/main/io/rcdevice.c" 3 4
_Bool 
# 334 "./src/main/io/rcdevice.c"
    runcamDeviceInit(runcamDevice_t *device)
{
    serialPortFunction_e portID = FUNCTION_RCDEVICE;
    serialPortConfig_t *portConfig = findSerialPortConfig(portID);
    if (portConfig != 
# 338 "./src/main/io/rcdevice.c" 3 4
                     ((void *)0)
# 338 "./src/main/io/rcdevice.c"
                         ) {
        device->serialPort = openSerialPort(portConfig->identifier, portID, 
# 339 "./src/main/io/rcdevice.c" 3 4
                                                                           ((void *)0)
# 339 "./src/main/io/rcdevice.c"
                                                                               , 
# 339 "./src/main/io/rcdevice.c" 3 4
                                                                                 ((void *)0)
# 339 "./src/main/io/rcdevice.c"
                                                                                     , 115200, MODE_RXTX, SERIAL_NOT_INVERTED);

        if (device->serialPort != 
# 341 "./src/main/io/rcdevice.c" 3 4
                                 ((void *)0)
# 341 "./src/main/io/rcdevice.c"
                                     ) {


            uint8_t respBuf[64];
            if (runcamDeviceGetDeviceInfo(device, respBuf)) {
                device->info.protocolVersion = respBuf[1];

                uint8_t featureLowBits = respBuf[2];
                uint8_t featureHighBits = respBuf[3];
                device->info.features = (featureHighBits << 8) | featureLowBits;

                return 
# 352 "./src/main/io/rcdevice.c" 3 4
                      1
# 352 "./src/main/io/rcdevice.c"
                          ;
            }

            closeSerialPort(device->serialPort);
        }
    }

    device->serialPort = 
# 359 "./src/main/io/rcdevice.c" 3 4
                        ((void *)0)
# 359 "./src/main/io/rcdevice.c"
                            ;
    return 
# 360 "./src/main/io/rcdevice.c" 3 4
          0
# 360 "./src/main/io/rcdevice.c"
               ;
}


# 363 "./src/main/io/rcdevice.c" 3 4
_Bool 
# 363 "./src/main/io/rcdevice.c"
    runcamDeviceSimulateCameraButton(runcamDevice_t *device, uint8_t operation)
{
    if (device->info.protocolVersion == RCDEVICE_PROTOCOL_RCSPLIT_VERSION) {
        sendCtrlCommand(device, operation + 1);
    } else if (device->info.protocolVersion == RCDEVICE_PROTOCOL_VERSION_1_0) {
        runcamDeviceSendPacket(device, 0x01, &operation, sizeof(operation));
    } else {
        return 
# 370 "./src/main/io/rcdevice.c" 3 4
              0
# 370 "./src/main/io/rcdevice.c"
                   ;
    }

    return 
# 373 "./src/main/io/rcdevice.c" 3 4
          1
# 373 "./src/main/io/rcdevice.c"
              ;
}




# 378 "./src/main/io/rcdevice.c" 3 4
_Bool 
# 378 "./src/main/io/rcdevice.c"
    runcamDeviceOpen5KeyOSDCableConnection(runcamDevice_t *device)
{
    uint8_t actionID = 0xFF;
    uint8_t code = 0xFF;
    
# 382 "./src/main/io/rcdevice.c" 3 4
   _Bool 
# 382 "./src/main/io/rcdevice.c"
        r = runcamDeviceSend5KeyOSDCableConnectionEvent(device, RCDEVICE_PROTOCOL_5KEY_CONNECTION_OPEN, &actionID, &code);
    return r && (code == 1) && (actionID == RCDEVICE_PROTOCOL_5KEY_CONNECTION_OPEN);
}




# 388 "./src/main/io/rcdevice.c" 3 4
_Bool 
# 388 "./src/main/io/rcdevice.c"
    runcamDeviceClose5KeyOSDCableConnection(runcamDevice_t *device, uint8_t *resultCode)
{
    uint8_t actionID = 0xFF;
    uint8_t code = 0xFF;
    
# 392 "./src/main/io/rcdevice.c" 3 4
   _Bool 
# 392 "./src/main/io/rcdevice.c"
        r = runcamDeviceSend5KeyOSDCableConnectionEvent(device, RCDEVICE_PROTOCOL_5KEY_CONNECTION_CLOSE, &actionID, &code);
    if (resultCode) {
        *resultCode = code;
    }
    return r;
}



# 400 "./src/main/io/rcdevice.c" 3 4
_Bool 
# 400 "./src/main/io/rcdevice.c"
    runcamDeviceSimulate5KeyOSDCableButtonPress(runcamDevice_t *device, uint8_t operation)
{
    if (operation == RCDEVICE_PROTOCOL_5KEY_SIMULATION_NONE) {
        return 
# 403 "./src/main/io/rcdevice.c" 3 4
              0
# 403 "./src/main/io/rcdevice.c"
                   ;
    }

    if (runcamDeviceSendRequestAndWaitingResp(device, 0x02, &operation, sizeof(uint8_t), 
# 406 "./src/main/io/rcdevice.c" 3 4
                                                                                                                                   ((void *)0)
# 406 "./src/main/io/rcdevice.c"
                                                                                                                                       , 
# 406 "./src/main/io/rcdevice.c" 3 4
                                                                                                                                         ((void *)0)
# 406 "./src/main/io/rcdevice.c"
                                                                                                                                             )) {
        return 
# 407 "./src/main/io/rcdevice.c" 3 4
              1
# 407 "./src/main/io/rcdevice.c"
                  ;
    }

    return 
# 410 "./src/main/io/rcdevice.c" 3 4
          0
# 410 "./src/main/io/rcdevice.c"
               ;
}



# 414 "./src/main/io/rcdevice.c" 3 4
_Bool 
# 414 "./src/main/io/rcdevice.c"
    runcamDeviceSimulate5KeyOSDCableButtonRelease(runcamDevice_t *device)
{
    return runcamDeviceSendRequestAndWaitingResp(device, 0x03, 
# 416 "./src/main/io/rcdevice.c" 3 4
                                                                                                           ((void *)0)
# 416 "./src/main/io/rcdevice.c"
                                                                                                               , 0, 
# 416 "./src/main/io/rcdevice.c" 3 4
                                                                                                                    ((void *)0)
# 416 "./src/main/io/rcdevice.c"
                                                                                                                        , 
# 416 "./src/main/io/rcdevice.c" 3 4
                                                                                                                          ((void *)0)
# 416 "./src/main/io/rcdevice.c"
                                                                                                                              );
}



void runcamDeviceDispFillRegion(runcamDevice_t *device, uint8_t x, uint8_t y, uint8_t width, uint8_t height, uint8_t c)
{
    uint8_t paramsBuf[5];


    paramsBuf[0] = x;
    paramsBuf[1] = y;
    paramsBuf[2] = width;
    paramsBuf[3] = height;
    paramsBuf[4] = c;

    runcamDeviceSendPacket(device, 0x20, paramsBuf, sizeof(paramsBuf));
}



void runcamDeviceDispWriteChar(runcamDevice_t *device, uint8_t x, uint8_t y, uint8_t c)
{
    uint8_t paramsBuf[3];


    paramsBuf[0] = x;
    paramsBuf[1] = y;
    paramsBuf[2] = c;

    runcamDeviceSendPacket(device, 0x21, paramsBuf, sizeof(paramsBuf));
}

static void runcamDeviceDispWriteString(runcamDevice_t *device, uint8_t x, uint8_t y, const char *text, 
# 449 "./src/main/io/rcdevice.c" 3 4
                                                                                                       _Bool 
# 449 "./src/main/io/rcdevice.c"
                                                                                                            isHorizontal)
{
    uint8_t textLen = strlen(text);
    if (textLen > 60) {
        textLen = 60;
    }

    uint8_t paramsBufLen = 3 + textLen;
    uint8_t paramsBuf[62];

    paramsBuf[0] = paramsBufLen - 1;
    paramsBuf[1] = x;
    paramsBuf[2] = y;
    memcpy(paramsBuf + 3, text, textLen);

    uint8_t command = isHorizontal ? 0x22 : 0x23;
    runcamDeviceSendPacket(device, command, paramsBuf, paramsBufLen);
}



void runcamDeviceDispWriteHorizontalString(runcamDevice_t *device, uint8_t x, uint8_t y, const char *text)
{
    runcamDeviceDispWriteString(device, x, y, text, 
# 472 "./src/main/io/rcdevice.c" 3 4
                                                   1
# 472 "./src/main/io/rcdevice.c"
                                                       );
}

void runcamDeviceDispWriteVerticalString(runcamDevice_t *device, uint8_t x, uint8_t y, const char *text)
{
    runcamDeviceDispWriteString(device, x, y, text, 
# 477 "./src/main/io/rcdevice.c" 3 4
                                                   0
# 477 "./src/main/io/rcdevice.c"
                                                        );
}

void runcamDeviceDispWriteChars(runcamDevice_t *device, uint8_t *data, uint8_t datalen)
{
    uint8_t adjustedDataLen = datalen;
    if (adjustedDataLen > 60) {
        adjustedDataLen = 60;
    }

    uint8_t paramsBufLen = adjustedDataLen + 1;
    uint8_t paramsBuf[62];

    paramsBuf[0] = adjustedDataLen;
    memcpy(paramsBuf + 1, data, adjustedDataLen);

    runcamDeviceSendPacket(device, 0x24, paramsBuf, paramsBufLen);
}

static 
# 496 "./src/main/io/rcdevice.c" 3 4
      _Bool 
# 496 "./src/main/io/rcdevice.c"
           runcamDeviceDecodeSettings(sbuf_t *buf, runcamDeviceSetting_t *outSettingList, int maxSettingItemCount)
{
    if (outSettingList == 
# 498 "./src/main/io/rcdevice.c" 3 4
                         ((void *)0)
# 498 "./src/main/io/rcdevice.c"
                             ) {
        return 
# 499 "./src/main/io/rcdevice.c" 3 4
              0
# 499 "./src/main/io/rcdevice.c"
                   ;
    }

    if (maxSettingItemCount > 32)
        maxSettingItemCount = 32;

    runcamDeviceSettingParseStep_e parseStep = RCDP_SETTING_PARSE_WAITING_ID;
    memset(outSettingList, 0, maxSettingItemCount * sizeof(runcamDeviceSetting_t));
    runcamDeviceSetting_t *settingIterator = outSettingList;
    while (sbufBytesRemaining(buf) > 0) {
        if (settingIterator >= (outSettingList + maxSettingItemCount)) {
            break;
        }

        switch (parseStep) {
        case RCDP_SETTING_PARSE_WAITING_ID: {
            settingIterator->id = sbufReadU8(buf);
            parseStep = RCDP_SETTING_PARSE_WAITING_NAME;
        }
            break;
        case RCDP_SETTING_PARSE_WAITING_NAME: {
            const char *str = (const char *)sbufConstPtr(buf);
            uint8_t nameLen = strlen(str) + 1;
            memset(settingIterator->name, 0, 20);
            strncpy(settingIterator->name, str, 20);
            sbufAdvance(buf, nameLen);

            parseStep = RCDP_SETTING_PARSE_WAITING_VALUE;
        }
            break;
        case RCDP_SETTING_PARSE_WAITING_VALUE: {
            const char *str = (const char *)sbufConstPtr(buf);
            uint8_t valueLen = strlen(str) + 1;
            memset(settingIterator->value, 0, 20);
            strcpy(settingIterator->value, str);
            sbufAdvance(buf, valueLen);
            parseStep = RCDP_SETTING_PARSE_WAITING_ID;

            settingIterator++;
        }
            break;
        }
    }

    if (RCDP_SETTING_PARSE_WAITING_ID != parseStep) {
        return 
# 544 "./src/main/io/rcdevice.c" 3 4
              0
# 544 "./src/main/io/rcdevice.c"
                   ;
    }

    return 
# 547 "./src/main/io/rcdevice.c" 3 4
          1
# 547 "./src/main/io/rcdevice.c"
              ;
}

static 
# 550 "./src/main/io/rcdevice.c" 3 4
      _Bool 
# 550 "./src/main/io/rcdevice.c"
           runcamDeviceGetResponseWithMultipleChunk(runcamDevice_t *device, uint8_t command, uint8_t settingID, uint8_t *responseData, uint16_t *responseDatalen)
{
    if (responseData == 
# 552 "./src/main/io/rcdevice.c" 3 4
                       ((void *)0) 
# 552 "./src/main/io/rcdevice.c"
                            || responseDatalen == 
# 552 "./src/main/io/rcdevice.c" 3 4
                                                  ((void *)0)
# 552 "./src/main/io/rcdevice.c"
                                                      ) {
        return 
# 553 "./src/main/io/rcdevice.c" 3 4
              0
# 553 "./src/main/io/rcdevice.c"
                   ;
    }


    uint8_t paramsBuf[2];
    uint8_t chunkIndex = 0;
    paramsBuf[0] = settingID;
    paramsBuf[1] = chunkIndex;

    uint8_t outputBufLen = 64;
    uint8_t outputBuf[64];
    
# 564 "./src/main/io/rcdevice.c" 3 4
   _Bool 
# 564 "./src/main/io/rcdevice.c"
        result = runcamDeviceSendRequestAndWaitingResp(device, command, paramsBuf, sizeof(paramsBuf), outputBuf, &outputBufLen);
    if (!result) {
        return 
# 566 "./src/main/io/rcdevice.c" 3 4
              0
# 566 "./src/main/io/rcdevice.c"
                   ;
    }

    uint8_t remainingChunk = outputBuf[1];

    if (remainingChunk >= 12) {
        return 
# 572 "./src/main/io/rcdevice.c" 3 4
              0
# 572 "./src/main/io/rcdevice.c"
                   ;
    }


    const uint16_t maxDataLen = 12 * 62;

    sbuf_t dataBuf;
    dataBuf.ptr = responseData;
    dataBuf.end = responseData + maxDataLen;
    sbufWriteData(&dataBuf, outputBuf + 3, outputBufLen - 4);


    while (remainingChunk > 0) {
        paramsBuf[1] = ++chunkIndex;

        outputBufLen = 64;
        result = runcamDeviceSendRequestAndWaitingResp(device, command, paramsBuf, sizeof(paramsBuf), outputBuf, &outputBufLen);

        if (!result) {
            return 
# 591 "./src/main/io/rcdevice.c" 3 4
                  0
# 591 "./src/main/io/rcdevice.c"
                       ;
        }



        sbufWriteData(&dataBuf, outputBuf + 3, outputBufLen - 4);

        remainingChunk--;
    }

    sbufSwitchToReader(&dataBuf, responseData);
    *responseDatalen = sbufBytesRemaining(&dataBuf);

    return 
# 604 "./src/main/io/rcdevice.c" 3 4
          1
# 604 "./src/main/io/rcdevice.c"
              ;
}





# 610 "./src/main/io/rcdevice.c" 3 4
_Bool 
# 610 "./src/main/io/rcdevice.c"
    runcamDeviceGetSettings(runcamDevice_t *device, uint8_t parentSettingID, runcamDeviceSetting_t *outSettingList, int maxSettingItemCount)
{
    if (outSettingList == 
# 612 "./src/main/io/rcdevice.c" 3 4
                         ((void *)0)
# 612 "./src/main/io/rcdevice.c"
                             ) {
        return 
# 613 "./src/main/io/rcdevice.c" 3 4
              0
# 613 "./src/main/io/rcdevice.c"
                   ;
    }

    uint16_t responseDataLength = 0;
    uint8_t data[12 * 62];
    if (!runcamDeviceGetResponseWithMultipleChunk(device, 0x10, parentSettingID, data, &responseDataLength)) {
        return 
# 619 "./src/main/io/rcdevice.c" 3 4
              0
# 619 "./src/main/io/rcdevice.c"
                   ;
    }

    sbuf_t dataBuf;
    dataBuf.ptr = data;
    dataBuf.end = data + responseDataLength;


    if (!runcamDeviceDecodeSettings(&dataBuf, outSettingList, maxSettingItemCount)) {
        return 
# 628 "./src/main/io/rcdevice.c" 3 4
              0
# 628 "./src/main/io/rcdevice.c"
                   ;
    }

    return 
# 631 "./src/main/io/rcdevice.c" 3 4
          1
# 631 "./src/main/io/rcdevice.c"
              ;
}

static 
# 634 "./src/main/io/rcdevice.c" 3 4
      _Bool 
# 634 "./src/main/io/rcdevice.c"
           runcamDeviceDecodeSettingDetail(sbuf_t *buf, runcamDeviceSettingDetail_t *outSettingDetail)
{
    if (outSettingDetail == 
# 636 "./src/main/io/rcdevice.c" 3 4
                           ((void *)0) 
# 636 "./src/main/io/rcdevice.c"
                                || sbufBytesRemaining(buf) == 0) {
        return 
# 637 "./src/main/io/rcdevice.c" 3 4
              0
# 637 "./src/main/io/rcdevice.c"
                   ;
    }

    rcdeviceSettingType_e settingType = sbufReadU8(buf);
    outSettingDetail->type = settingType;
    switch (settingType) {
    case RCDEVICE_PROTOCOL_SETTINGTYPE_UINT8:
    case RCDEVICE_PROTOCOL_SETTINGTYPE_INT8:
        outSettingDetail->value = sbufReadU8(buf);
        outSettingDetail->minValue = sbufReadU8(buf);
        outSettingDetail->maxValue = sbufReadU8(buf);
        outSettingDetail->stepSize = sbufReadU8(buf);
        break;
    case RCDEVICE_PROTOCOL_SETTINGTYPE_UINT16:
    case RCDEVICE_PROTOCOL_SETTINGTYPE_INT16:
        outSettingDetail->value = sbufReadU16(buf);
        outSettingDetail->minValue = sbufReadU16(buf);
        outSettingDetail->maxValue = sbufReadU16(buf);
        outSettingDetail->stepSize = sbufReadU8(buf);
        break;
    case RCDEVICE_PROTOCOL_SETTINGTYPE_FLOAT:
        outSettingDetail->value = sbufReadU32(buf);
        outSettingDetail->minValue = sbufReadU32(buf);
        outSettingDetail->maxValue = sbufReadU32(buf);
        outSettingDetail->decimalPoint = sbufReadU8(buf);
        outSettingDetail->stepSize = sbufReadU32(buf);
        break;
    case RCDEVICE_PROTOCOL_SETTINGTYPE_TEXT_SELECTION: {
        outSettingDetail->value = sbufReadU8(buf);

        const char *tmp = (const char *)sbufConstPtr(buf);
        const uint16_t maxLen = 62 * 30;
        char textSels[maxLen];
        memset(textSels, 0, maxLen);
        strncpy(textSels, tmp, maxLen);
        char delims[] = ";";
        char *result = strtok(textSels, delims);
        int i = 0;
        runcamDeviceSettingTextSelection_t *iterator = outSettingDetail->textSelections;
        while (result != 
# 676 "./src/main/io/rcdevice.c" 3 4
                        ((void *)0)
# 676 "./src/main/io/rcdevice.c"
                            ) {
            if (i >= 30) {
                break;
            }

            memset(iterator->text, 0, 20);
            strncpy(iterator->text, result, 20);
            iterator++;
            result = strtok(
# 684 "./src/main/io/rcdevice.c" 3 4
                           ((void *)0)
# 684 "./src/main/io/rcdevice.c"
                               , delims);
            i++;
        }
    }
        break;
    case RCDEVICE_PROTOCOL_SETTINGTYPE_STRING: {
        const char *tmp = (const char *)sbufConstPtr(buf);
        strncpy(outSettingDetail->stringValue, tmp, 58);
        sbufAdvance(buf, strlen(tmp) + 1);

        outSettingDetail->maxStringSize = sbufReadU8(buf);
    }
        break;
    case RCDEVICE_PROTOCOL_SETTINGTYPE_FOLDER:
        break;
    case RCDEVICE_PROTOCOL_SETTINGTYPE_INFO: {
        const char *tmp = (const char *)sbufConstPtr(buf);
        strncpy(outSettingDetail->stringValue, tmp, 58);
        sbufAdvance(buf, strlen(outSettingDetail->stringValue) + 1);
    }
        break;
    case RCDEVICE_PROTOCOL_SETTINGTYPE_UNKNOWN:
        break;
    }

    return 
# 709 "./src/main/io/rcdevice.c" 3 4
          1
# 709 "./src/main/io/rcdevice.c"
              ;
}





# 715 "./src/main/io/rcdevice.c" 3 4
_Bool 
# 715 "./src/main/io/rcdevice.c"
    runcamDeviceGetSettingDetail(runcamDevice_t *device, uint8_t settingID, runcamDeviceSettingDetail_t *outSettingDetail)
{
    if (outSettingDetail == 
# 717 "./src/main/io/rcdevice.c" 3 4
                           ((void *)0)
# 717 "./src/main/io/rcdevice.c"
                               )
        return 
# 718 "./src/main/io/rcdevice.c" 3 4
              0
# 718 "./src/main/io/rcdevice.c"
                   ;

    uint16_t responseDataLength = 0;
    uint8_t data[12 * 62];
    if (!runcamDeviceGetResponseWithMultipleChunk(device, 0x11, settingID, data, &responseDataLength)) {
        return 
# 723 "./src/main/io/rcdevice.c" 3 4
              0
# 723 "./src/main/io/rcdevice.c"
                   ;
    }

    sbuf_t dataBuf;
    dataBuf.ptr = data;
    dataBuf.end = data + responseDataLength;


    if (!runcamDeviceDecodeSettingDetail(&dataBuf, outSettingDetail)) {
        return 
# 732 "./src/main/io/rcdevice.c" 3 4
              0
# 732 "./src/main/io/rcdevice.c"
                   ;
    }

    return 
# 735 "./src/main/io/rcdevice.c" 3 4
          1
# 735 "./src/main/io/rcdevice.c"
              ;
}



# 739 "./src/main/io/rcdevice.c" 3 4
_Bool 
# 739 "./src/main/io/rcdevice.c"
    runcamDeviceWriteSetting(runcamDevice_t *device, uint8_t settingID, uint8_t *paramData, uint8_t paramDataLen, runcamDeviceWriteSettingResponse_t *response)
{
    if (response == 
# 741 "./src/main/io/rcdevice.c" 3 4
                   ((void *)0) 
# 741 "./src/main/io/rcdevice.c"
                        || paramDataLen > (62 - 1)) {
        return 
# 742 "./src/main/io/rcdevice.c" 3 4
              0
# 742 "./src/main/io/rcdevice.c"
                   ;
    }

    memset(response, 0, sizeof(runcamDeviceWriteSettingResponse_t));
    response->resultCode = 1;

    uint8_t paramsBufLen = sizeof(uint8_t) + paramDataLen;
    uint8_t paramsBuf[62];
    paramsBuf[0] = settingID;
    memcpy(paramsBuf + 1, paramData, paramDataLen);

    uint8_t outputBufLen = 64;
    uint8_t outputBuf[64];
    
# 755 "./src/main/io/rcdevice.c" 3 4
   _Bool 
# 755 "./src/main/io/rcdevice.c"
        result = runcamDeviceSendRequestAndWaitingResp(device, 0x13, paramsBuf, paramsBufLen, outputBuf, &outputBufLen);
    if (!result) {
        return 
# 757 "./src/main/io/rcdevice.c" 3 4
              0
# 757 "./src/main/io/rcdevice.c"
                   ;
    }

    response->resultCode = outputBuf[1];
    response->needUpdateMenuItems = outputBuf[2];

    return 
# 763 "./src/main/io/rcdevice.c" 3 4
          1
# 763 "./src/main/io/rcdevice.c"
              ;
}
